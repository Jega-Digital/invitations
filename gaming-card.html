<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Loot Drop</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the Cyberpunk/Neon look */
        :root {
            --neon-purple: #9d00ff;
            --neon-green: #00ff88;
            --deep-dark: #10081d;
            --scratch-color: #2e0d5a;
        }

        body {
            background-color: var(--deep-dark);
            font-family: 'Orbitron', sans-serif;
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* The Card Container - Giving it a glowing border effect */
        .cyber-card {
            box-shadow: 0 0 20px var(--neon-purple), 0 0 10px var(--neon-green) inset;
            border: 3px solid var(--neon-purple);
            background: linear-gradient(145deg, #1f0c3d, #0d061c);
            animation: pulse-glow 3s infinite alternate;
        }

        /* Neon Text and Button Styles */
        .neon-text {
            color: var(--neon-green);
            text-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green);
        }

        .neon-purple-text {
            color: var(--neon-purple);
            text-shadow: 0 0 5px var(--neon-purple);
        }

        .copy-button {
            background: var(--neon-purple);
            box-shadow: 0 0 10px var(--neon-purple);
            transition: all 0.2s;
        }
        .copy-button:hover {
            background: var(--neon-green);
            box-shadow: 0 0 15px var(--neon-green);
            transform: translateY(-2px);
        }

        /* Canvas Style - The Scratchable Area */
        #scratchCanvas {
            touch-action: none; /* Crucial for mobile scrolling/scratching */
            border: 2px solid var(--neon-green);
            background-color: transparent; /* Changed to transparent so the parent's pixel pattern shows through */
        }

        /* Keyframe animation for the card pulse */
        @keyframes pulse-glow {
            0% { border-color: var(--neon-purple); box-shadow: 0 0 10px var(--neon-purple); }
            100% { border-color: var(--neon-green); box-shadow: 0 0 20px var(--neon-green); }
        }

        /* Text bounce animation for copy feedback */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .bouncing {
            animation: bounce 0.3s ease-in-out;
        }

        /* Pixel art pattern for the scratch layer */
        #pixelPattern {
            background-color: var(--scratch-color);
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);
            background-size: 8px 8px; /* Pixel size for the pattern */
            border-radius: 12px;
        }
    </style>
</head>
<body class="p-4">

    <!-- Main Card Container -->
    <div id="cardContainer" class="cyber-card w-full max-w-sm p-6 sm:p-8 rounded-2xl text-center flex flex-col items-center space-y-6">

        <!-- Header and Title -->
        <h1 id="topTitle" class="text-3xl sm:text-4xl font-black tracking-widest neon-purple-text">CUSTOM TITLE HERE</h1>
        <p id="subHeader" class="text-xs sm:text-sm tracking-widest uppercase neon-text">Scratch Off Panel to see your Gift!</p>

        <!-- Hidden Code Display -->
        <div class="w-full text-center">
            <p class="text-sm sm:text-base mb-2">Your Gift Code:</p>
            <div class="relative inline-block w-full">
                <!-- Hidden area where code is revealed -->
                <div id="codeDisplay" class="bg-gray-900 border-2 border-dashed border-gray-700 py-3 sm:py-4 px-4 rounded-xl text-2xl sm:text-3xl font-bold tracking-widest">
                    <span id="giftCode" class="text-red-500">SCRATCH TO REVEAL</span>
                </div>
                <!-- Canvas Scratch Layer -->
                <div id="pixelPattern" class="absolute inset-0 z-10 rounded-xl overflow-hidden">
                    <canvas id="scratchCanvas" class="w-full h-full"></canvas>
                </div>
            </div>
        </div>

        <!-- Copy Button -->
        <button id="copyButton" class="copy-button w-full px-6 py-3 text-lg font-bold uppercase rounded-full tracking-wider text-white">
            Copy Code
        </button>
        <p id="copyFeedback" class="text-xs h-4 text-center text-red-400 invisible"></p>


        <!-- Detailed Message Area -->
        <div id="messageContainer" class="w-full text-center space-y-3 p-4 border-2 border-gray-800 rounded-xl">
            <p id="detailedMessage" class="text-sm sm:text-base text-gray-400 italic">
                This is a fully customizable message area. Use this for specific instructions, terms, or a personal greeting from the sender.
            </p>
        </div>

        <!-- Call to Action -->
        <p class="text-xs text-gray-500 pt-2">Powered by Jega Digital Scratch</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const codeDisplay = document.getElementById('giftCode');
            const topTitleEl = document.getElementById('topTitle');
            const messageEl = document.getElementById('detailedMessage');
            const copyButton = document.getElementById('copyButton');
            const copyFeedback = document.getElementById('copyFeedback');
            const canvas = document.getElementById('scratchCanvas');
            const pixelPattern = document.getElementById('pixelPattern');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            let isScratching = false;
            let percentScratched = 0;
            const REVEAL_THRESHOLD = 60; // Percent of area scratched before full reveal

            // --- 1. Get Data from URL Parameters ---
            const urlParams = new URLSearchParams(window.location.search);
            const giftCode = urlParams.get('code') || 'DEFAULT-LOOT-CODE';
            const topTitle = urlParams.get('title');
            const message = urlParams.get('message');
            
            codeDisplay.textContent = giftCode; // Set the underlying code

            // --- Overwrite customizable fields if parameters exist ---
            if (topTitle) {
                topTitleEl.textContent = topTitle;
            }
            if (message) {
                messageEl.textContent = message;
            }

            // --- 2. Canvas Setup (Scratch Layer) ---
            function setupCanvas() {
                // Ensure canvas size matches its container (pixelPattern)
                const containerRect = pixelPattern.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = containerRect.width * dpr;
                canvas.height = containerRect.height * dpr;
                ctx.scale(dpr, dpr);

                // --- Draw the opaque layer to be erased ---
                ctx.globalCompositeOperation = 'source-over'; // Temporarily switch to drawing mode
                
                // Get the computed background color from the CSS variable
                const scratchColor = getComputedStyle(document.documentElement).getPropertyValue('--scratch-color').trim() || '#2e0d5a';
                ctx.fillStyle = scratchColor;
                ctx.fillRect(0, 0, containerRect.width, containerRect.height);

                // Now, set up the context for "erasing" the mask
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 60; /* INCREASED BRUSH SIZE FOR FASTER SCRATCHING */
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
            }
            
            window.addEventListener('resize', setupCanvas); // Handle responsiveness

            // --- 3. Scratching Logic ---

            function getCursorPosition(e) {
                const rect = canvas.getBoundingClientRect();
                let x, y;

                if (e.touches && e.touches.length > 0) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                return { x, y };
            }

            function startScratch(e) {
                isScratching = true;
                ctx.beginPath();
                const pos = getCursorPosition(e);
                ctx.moveTo(pos.x, pos.y);
                e.preventDefault(); // Prevent scrolling on touch devices
            }

            function scratchMove(e) {
                if (!isScratching) return;
                const pos = getCursorPosition(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                e.preventDefault(); 
            }

            function endScratch() {
                isScratching = false;
                checkScratchProgress();
            }

            function checkScratchProgress() {
                // Check transparency (how much of the canvas has been "erased")
                const w = canvas.width;
                const h = canvas.height;
                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;
                
                let totalPixels = 0;
                let transparentPixels = 0;

                // Checking the alpha channel 
                for (let i = 3; i < data.length; i += 4) {
                    totalPixels++;
                    if (data[i] === 0) { // Check the alpha channel (0 means transparent/erased)
                        transparentPixels++;
                    }
                }
                
                percentScratched = (transparentPixels / totalPixels) * 100;
                
                if (percentScratched >= REVEAL_THRESHOLD) {
                    // Fully reveal the code
                    pixelPattern.style.transition = 'opacity 1s ease-out';
                    pixelPattern.style.opacity = '0';
                    setTimeout(() => {
                        pixelPattern.style.display = 'none';
                        codeDisplay.classList.remove('text-red-500');
                        codeDisplay.classList.add('neon-text'); 
                    }, 1000);
                }
            }

            // Attach Event Listeners
            canvas.addEventListener('mousedown', startScratch);
            canvas.addEventListener('mousemove', scratchMove);
            window.addEventListener('mouseup', endScratch);

            canvas.addEventListener('touchstart', startScratch, { passive: false });
            canvas.addEventListener('touchmove', scratchMove, { passive: false });
            window.addEventListener('touchend', endScratch);

            // --- 4. Copy Code Logic (Robust Implementation) ---

            copyButton.addEventListener('click', () => {
                const codeToCopy = codeDisplay.textContent;

                // 1. Use modern navigator.clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(codeToCopy)
                        .then(() => showCopyFeedback(true))
                        .catch(() => fallbackCopy(codeToCopy)); // Fallback if permission is denied
                } else {
                    // 2. Use document.execCommand fallback
                    fallbackCopy(codeToCopy);
                }
            });

            function fallbackCopy(text) {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed'; // Prevents scrolling to bottom
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    
                    const success = document.execCommand('copy');
                    document.body.removeChild(textarea);

                    if (success) {
                        showCopyFeedback(true);
                    } else {
                        showCopyFeedback(false);
                    }
                } catch (err) {
                    console.error('Copy failed completely:', err);
                    showCopyFeedback(false);
                }
            }

            function showCopyFeedback(success) {
                copyFeedback.textContent = success ? 'CODE COPIED!' : 'ERROR: Copy Failed.';
                copyFeedback.className = 'text-xs h-4 text-center ' + (success ? 'neon-text bouncing' : 'text-red-500');
                copyFeedback.classList.remove('invisible');
                copyButton.textContent = success ? 'COPIED!' : 'Copy Code';

                setTimeout(() => {
                    copyFeedback.classList.add('invisible');
                    copyButton.textContent = 'Copy Code';
                }, 1500);
            }

            // Initial setup call
            setupCanvas();
        });
    </script>
</body>
</html>